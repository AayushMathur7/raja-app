"raja-app-main/server/embeddings.py import os\nimport zipfile\nfrom io import BytesIO\nfrom urllib.parse import urlparse\nfrom urllib.request import urlopen\n\nimport pandas as pd\nimport pinecone\nimport tiktoken\nfrom dotenv import load_dotenv\nfrom langchain.chains.query_constructor.schema import AttributeInfo\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain.vectorstores import Pinecone\nfrom tqdm import tqdm\n\n# Load environment variables from .env file\nload_dotenv()\n\nGH_TOKEN = os.environ.get(\"GH_TOKEN\", \"\")\nPINECONE_API_KEY = os.environ.get(\"PINECONE_API_KEY\", \"\")\nPINECONE_ENVIRONMENT = os.environ.get(\"PINECONE_ENVIRONMENT\", \"dev\")\nOPEN_AI_KEY = os.environ.get(\"OPEN_AI_KEY\", \"\")\n\nembeddings = OpenAIEmbeddings(\n    openai_api_key=OPEN_AI_KEY,\n)\nencoder = tiktoken.get_encoding(\"cl100k_base\")\npinecone.init(\n    api_key=PINECONE_API_KEY,\n    environment=PINECONE_ENVIRONMENT,\n)\nvector_store = Pinecone(\n    index=pinecone.Index(\"raja-app\"),\n    embedding_function=embeddings.embed_query,\n    text_key=\"text\",\n    namespace=\"raja-app\",\n)\nmetadata_field_info = [\n    AttributeInfo(\n        name=\"document_id\",\n        description=\"The file path where the code is stored\",\n        type=\"string\",\n    ),\n]\n\n\ndef execute_embedding_workflow(repo_url, folder_path):\n    print(\"Executing embedding workflow\")\n    splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=0)\n\n    total_tokens, corpus_summary = 0, []\n    file_texts, metadatas = [], []\n    # Assumes that the repo is public\n    with zipfile_from_github(repo_url) as zip_ref:\n        print(\"Extracting zip file\")\n        zip_file_list = zip_ref.namelist()\n\n        pbar = tqdm(zip_file_list, desc=f\"Total tokens: 0\")\n        for file_name in pbar:\n            print(file_name)\n            if (\n                file_name.endswith(\"/\")\n                or any(\n                    f in file_name\n                    for f in [\".DS_Store\", \".gitignore\", \".next\", \".json\"]\n                )\n                or any(\n                    file_name.endswith(ext)\n                    for ext in [\".png\", \".jpg\", \".jpeg\", \".svg\", \".ico\"]\n                )\n            ):\n                continue\n            else:\n                with zip_ref.open(file_name, \"r\") as file:\n                    file_contents = str(file.read())\n                    file_name_trunc = str(file_name).replace(folder_path, \"\")\n\n                    n_tokens = len(encoder.encode(file_contents))\n                    total_tokens += n_tokens\n                    corpus_summary.append(\n                        {\"file_name\": file_name_trunc, \"n_tokens\": n_tokens}\n                    )\n\n                    file_texts.append(file_contents)\n                    metadatas.append({\"document_id\": file_name_trunc})\n                    pbar.set_description(f\"Total tokens: {total_tokens}\")\n\n    split_documents = splitter.create_documents(file_texts, metadatas=metadatas)\n    vector_store.from_documents(\n        documents=split_documents,\n        embedding=embeddings,\n        index_name=\"raja-app\",\n        namespace=\"raja-app\",\n    )\n\n    pd.DataFrame.from_records(corpus_summary).to_csv(\n        \"data/corpus_summary.csv\", index=False\n    )\n    print(\"Embedding workflow executed successfully\")\n    return {}\n\n\ndef embed_document(vector_db, splitter, document_id, document):\n    metadata = [{\"document_id\": document_id}]\n    split_documents = splitter.create_documents([str(document)], metadatas=metadata)\n\n    texts = [d.page_content for d in split_documents]\n    metadatas = [d.metadata for d in split_documents]\n\n    docsearch = vector_db.add_texts(texts, metadatas=metadatas)\n\n\n# Only for public repos\ndef zipfile_from_github(repo_url):\n    http_response = urlopen(repo_url)\n    zf = BytesIO(http_response.read())\n    return zipfile.ZipFile(zf, \"r\")\n\n\ndef compute_prefix_and_zip_url(repo_url, main_branch=\"main\"):\n    parsed = urlparse(repo_url)\n    if not all([parsed.scheme, parsed.netloc]):\n        raise ValueError(\"Invalid URL: \" + repo_url)\n\n    path_parts = parsed.path.strip(\"/\").split(\"/\")\n    repo_name = path_parts[-1] if parsed.path.endswith(\".git\") else path_parts[-2]\n    if not repo_name:\n        raise ValueError(\"Invalid repository URL: \" + repo_url)\n\n    folder_prefix = f\"{repo_name}-{main_branch}\"\n\n    # Ensure that the URL is a GitHub repository URL\n    if parsed.netloc != \"github.com\":\n        raise ValueError(\"Invalid GitHub repository URL\")\n\n    # Extract the username and repository name\n    if len(path_parts) < 2:\n        raise ValueError(\"Invalid GitHub repository URL\")\n\n    username = path_parts[0]\n    repo = path_parts[1]\n\n    # Construct the .zip file URL\n    zip_url = (\n        f\"https://github.com/{username}/{repo}/archive/refs/heads/{main_branch}.zip\"\n    )\n\n    return folder_prefix, zip_url\n\n\ndef get_repo_info(url):\n    # Parse the URL and split the path\n    parsed_url = urlparse(url)\n    path_parts = parsed_url.path.split(\"/\")\n\n    # The repo name is the last part of the path\n    repo_name = path_parts[-1]\n\n    # The owner is the second-to-last part of the path\n    owner = path_parts[-2]\n\n    return owner, repo_name\n raja-app-main/tickets.jsonl {\"name\": \"Unhandled runtime error\", \"type\": \"Bug\", \"description\": \"An unhandled runtime error was encountered in Speakers.jsx. The issue is caused by a ReferenceError as mediaVariable is not defined, which results in a failure during the execution.\", \"acceptance_criteria\": \"The reference error should be fixed, and the addEventListener method call on the mediaVariable variable should be successful. There should be no runtime errors related to undefined variables in Speakers.jsx, and all functionality dependent on the mediaVariable variable should work as expected.\", \"how_to_reproduce\": \"The error is located at line 172 in the Speakers.jsx file. The steps to reproduce this error are not yet fully identified, so further investigation is required to determine the sequence of actions leading to this error.\"}\n{\"name\": \"Embeddings compute prefix error\", \"type\": \"Bug\", \"description\": \"There's a type error in the embeddings.compute_prefix_and_zip_url function. It fails when a non-string argument is passed.\", \"acceptance_criteria\": \"The compute_prefix_and_zip_url function should handle non-string inputs gracefully without throwing a type error. It should provide a meaningful error message indicating the incorrect input type.\", \"how_to_reproduce\": \"This error can be reproduced by calling the compute_prefix_and_zip_url function with a non-string argument. Further investigation is required to determine if there are other inputs that could lead to this error.\"}\n{\"name\": \"New endpoint that provides status of embedding workflow\", \"type\": \"Feature\", \"description\": \"We need an endpoint that provides status of the embedding workflow. This endpoint should return the current stage of the workflow and estimated time for completion.\", \"acceptance_criteria\": \"A new endpoint /v1/status should be created that returns a JSON response with the current stage of the workflow and an estimated time to completion. The endpoint should handle errors gracefully and provide meaningful messages in case of failures.\", \"how_to_reproduce\": \"\"}\n{\"name\": \"Intermittent failure of run-raja endpoint\", \"type\": \"Bug\", \"description\": \"The /v1/run-raja endpoint is failing intermittently with a 500 internal server error. The error message indicates a failure in the raja.raja_agent function.\", \"acceptance_criteria\": \"The /v1/run-raja endpoint should handle failures in the raja_agent function gracefully and provide meaningful error messages to the client. It should not return a 500 internal server error.\", \"how_to_reproduce\": \"This error can be reproduced by making multiple concurrent requests to the /v1/run-raja endpoint. Further investigation is required to determine the exact conditions leading to the error.\"}\n{\"name\": \"Logging to debug flask app\", \"type\": \"Feature\", \"description\": \"We need to add logging to our Flask app to better track and debug errors. The logs should capture key actions like starting and completing the embedding workflow, starting and completing the Raja workflow, and any errors.\", \"acceptance_criteria\": \"Logging should be added to the Flask app. The logs should be written to a file that can be reviewed later. It should log key events in the application, including starting and completing workflows and any errors. The logs should include timestamps, the event description, and any relevant details.\", \"how_to_reproduce\": \"\"}\n raja-app-main/LICENSE.md # Tailwind UI License\n\n## Personal License\n\nTailwind Labs Inc. grants you an on-going, non-exclusive license to use the Components and Templates.\n\nThe license grants permission to **one individual** (the Licensee) to access and use the Components and Templates.\n\nYou **can**:\n\n- Use the Components and Templates to create unlimited End Products.\n- Modify the Components and Templates to create derivative components and templates. Those components and templates are subject to this license.\n- Use the Components and Templates to create unlimited End Products for unlimited Clients.\n- Use the Components and Templates to create End Products where the End Product is sold to End Users.\n- Use the Components and Templates to create End Products that are open source and freely available to End Users.\n\nYou **cannot**:\n\n- Use the Components and Templates to create End Products that are designed to allow an End User to build their own End Products using the Components and Templates or derivatives of the Components and Templates.\n- Re-distribute the Components and Templates or derivatives of the Components and Templates separately from an End Product, neither in code or as design assets.\n- Share your access to the Components and Templates with any other individuals.\n- Use the Components and Templates to produce anything that may be deemed by Tailwind Labs Inc, in their sole and absolute discretion, to be competitive or in conflict with the business of Tailwind Labs Inc.\n\n### Example usage\n\nExamples of usage **allowed** by the license:\n\n- Creating a personal website by yourself.\n- Creating a website or web application for a client that will be owned by that client.\n- Creating a commercial SaaS application (like an invoicing app for example) where end users have to pay a fee to use the application.\n- Creating a commercial self-hosted web application that is sold to end users for a one-time fee.\n- Creating a web application where the primary purpose is clearly not to simply re-distribute the components (like a conference organization app that uses the components for its UI for example) that is free and open source, where the source code is publicly available.\n\nExamples of usage **not allowed** by the license:\n\n- Creating a repository of your favorite Tailwind UI components or templates (or derivatives based on Tailwind UI components or templates) and publishing it publicly.\n- Creating a React or Vue version of Tailwind UI and making it available either for sale or for free.\n- Create a Figma or Sketch UI kit based on the Tailwind UI component designs.\n- Creating a \"website builder\" project where end users can build their own websites using components or templates included with or derived from Tailwind UI.\n- Creating a theme, template, or project starter kit using the components or templates and making it available either for sale or for free.\n- Creating an admin panel tool (like [Laravel Nova](https://nova.laravel.com/) or [ActiveAdmin](https://activeadmin.info/)) that is made available either for sale or for free.\n\nIn simple terms, use Tailwind UI for anything you like as long as it doesn't compete with Tailwind UI.\n\n### Personal License Definitions\n\nLicensee is the individual who has purchased a Personal License.\n\nComponents and Templates are the source code and design assets made available to the Licensee after purchasing a Tailwind UI license.\n\nEnd Product is any artifact produced that incorporates the Components or Templates or derivatives of the Components or Templates.\n\nEnd User is a user of an End Product.\n\nClient is an individual or entity receiving custom professional services directly from the Licensee, produced specifically for that individual or entity. Customers of software-as-a-service products are not considered clients for the purpose of this document.\n\n## Team License\n\nTailwind Labs Inc. grants you an on-going, non-exclusive license to use the Components and Templates.\n\nThe license grants permission for **up to 25 Employees and Contractors of the Licensee** to access and use the Components and Templates.\n\nYou **can**:\n\n- Use the Components and Templates to create unlimited End Products.\n- Modify the Components and Templates to create derivative components and templates. Those components and templates are subject to this license.\n- Use the Components and Templates to create unlimited End Products for unlimited Clients.\n- Use the Components and Templates to create End Products where the End Product is sold to End Users.\n- Use the Components and Templates to create End Products that are open source and freely available to End Users.\n\nYou **cannot**:\n\n- Use the Components or Templates to create End Products that are designed to allow an End User to build their own End Products using the Components or Templates or derivatives of the Components or Templates.\n- Re-distribute the Components or Templates or derivatives of the Components or Templates separately from an End Product.\n- Use the Components or Templates to create End Products that are the property of any individual or entity other than the Licensee or Clients of the Licensee.\n- Use the Components or Templates to produce anything that may be deemed by Tailwind Labs Inc, in their sole and absolute discretion, to be competitive or in conflict with the business of Tailwind Labs Inc.\n\n### Example usage\n\nExamples of usage **allowed** by the license:\n\n- Creating a website for your company.\n- Creating a website or web application for a client that will be owned by that client.\n- Creating a commercial SaaS application (like an invoicing app for example) where end users have to pay a fee to use the application.\n- Creating a commercial self-hosted web application that is sold to end users for a one-time fee.\n- Creating a web application where the primary purpose is clearly not to simply re-distribute the components or templates (like a conference organization app that uses the components or a template for its UI for example) that is free and open source, where the source code is publicly available.\n\nExamples of use **not allowed** by the license:\n\n- Creating a repository of your favorite Tailwind UI components or template (or derivatives based on Tailwind UI components or templates) and publishing it publicly.\n- Creating a React or Vue version of Tailwind UI and making it available either for sale or for free.\n- Creating a \"website builder\" project where end users can build their own websites using components or templates included with or derived from Tailwind UI.\n- Creating a theme or template using the components or templates and making it available either for sale or for free.\n- Creating an admin panel tool (like [Laravel Nova](https://nova.laravel.com/) or [ActiveAdmin](https://activeadmin.info/)) that is made available either for sale or for free.\n- Creating any End Product that is not the sole property of either your company or a client of your company. For example your employees/contractors can't use your company Tailwind UI license to build their own websites or side projects.\n\n### Team License Definitions\n\nLicensee is the business entity who has purchased a Team License.\n\nComponents and Templates are the source code and design assets made available to the Licensee after purchasing a Tailwind UI license.\n\nEnd Product is any artifact produced that incorporates the Components or Templates or derivatives of the Components or Templates.\n\nEnd User is a user of an End Product.\n\nEmployee is a full-time or part-time employee of the Licensee.\n\nContractor is an individual or business entity contracted to perform services for the Licensee.\n\nClient is an individual or entity receiving custom professional services directly from the Licensee, produced specifically for that individual or entity. Customers of software-as-a-service products are not considered clients for the purpose of this document.\n\n## Enforcement\n\nIf you are found to be in violation of the license, access to your Tailwind UI account will be terminated, and a refund may be issued at our discretion. When license violation is blatant and malicious (such as intentionally redistributing the Components or Templates through private warez channels), no refund will be issued.\n\nThe copyright of the Components and Templates is owned by Tailwind Labs Inc. You are granted only the permissions described in this license; all other rights are reserved. Tailwind Labs Inc. reserves the right to pursue legal remedies for any unauthorized use of the Components or Templates outside the scope of this license.\n\n## Liability\n\nTailwind Labs Inc.\u2019s liability to you for costs, damages, or other losses arising from your use of the Components or Templates \u2014 including third-party claims against you \u2014 is limited to a refund of your license fee. Tailwind Labs Inc. may not be held liable for any consequential damages related to your use of the Components or Templates.\n\nThis Agreement is governed by the laws of the Province of Ontario and the applicable laws of Canada. Legal proceedings related to this Agreement may only be brought in the courts of Ontario. You agree to service of process at the e-mail address on your original order.\n\n## Questions?\n\nUnsure which license you need, or unsure if your use case is covered by our licenses?\n\nEmail us at [support@tailwindui.com](mailto:support@tailwindui.com) with your questions.\n raja-app-main/server/app.py import os\nfrom pprint import pprint\n\nimport embeddings\nimport raja\nfrom dotenv import load_dotenv\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS, cross_origin\nfrom ghapi.all import GhApi\n\nfrom convex import ConvexClient\n\napp = Flask(\"Raja\")\ncors = CORS(app)\n\n# get the directory of the current script\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\n\n# go up one level to get the root directory\nroot_dir = os.path.dirname(current_dir)\n\ndotenv_path = os.path.join(root_dir, \".env.local\")\n\n# load the .env file\nload_dotenv(dotenv_path)\n\nclient = ConvexClient(os.getenv(\"NEXT_PUBLIC_CONVEX_URL\"))\nGH_TOKEN = os.getenv(\"GH_TOKEN\", \"\")\n\n\n@app.route(\"/v1/initialize-repo\", methods=[\"POST\"])\n@cross_origin()\ndef initalize_repo():\n    req_data = request.get_json()\n    repo_url = req_data[\"repo_url\"]\n    try:\n        folder_path, zip_url = embeddings.compute_prefix_and_zip_url(repo_url)\n        embeddings.execute_embedding_workflow(zip_url, folder_path)\n        repo_owner, repo_name = embeddings.get_repo_info(repo_url)\n        client.mutation(\n            \"repo:addRepo\", {\"url\": repo_url, \"owner\": repo_owner, \"name\": repo_name}\n        )\n    except ValueError as e:\n        return jsonify(error=str(e)), 400\n    return jsonify(message=\"Embedding workflow executed successfully\"), 200\n\n\n@app.route(\"/v1/run-raja\", methods=[\"POST\"])\ndef run_raja():\n    print(\"Running Raja\")\n    req_data = request.get_json()\n    print(req_data)\n    raja.raja_agent(req_data)\n    return jsonify(message=\"Raja workflow executed successfully\"), 200\n\n\n@app.route(\"/v1/delete-all-except-main\", methods=[\"POST\"])\ndef delete_all_except_main():\n    req_data = request.get_json()\n    repo_owner = req_data[\"repo_owner\"]\n    repo_name = req_data[\"repo_name\"]\n    ghapi = GhApi(owner=repo_owner, repo=repo_name, token=GH_TOKEN)\n\n    # Get all branches\n    branches = ghapi.repos.list_branches()\n\n    for branch in branches:\n        # Delete the branch if its name is not 'main'\n        if branch.name != \"main\":\n            try:\n                ghapi.git.delete_ref(ref=f\"heads/{branch.name}\")\n                print(f\"Deleted branch: {branch.name}\")\n            except Exception as e:\n                print(f\"Error deleting branch {branch.name}: {e}\")\n\n    return {}\n\n\n@app.route(\"/v1/get-ticket\", methods=[\"GET\"])\ndef get_tickets():\n    tickets = client.query(\"tickets:get\")\n    pprint(tickets)\n    return tickets\n\n\n@app.route(\"/v1/create-ticket\", methods=[\"POST\"])\ndef create_ticket():\n    req_data = request.get_json()\n    print(req_data)\n    client.mutation(\"tickets:createTicket\", req_data)\n    return {}\n\n\nif __name__ == \"__main__\":\n    app.run(port=5000, debug=True)\n "
